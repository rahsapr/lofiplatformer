// --- Setup and DOM Elements ---
const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
const startScreen = document.getElementById('startScreen'); const intermissionScreen = document.getElementById('intermissionScreen'); const gameCompleteScreen = document.getElementById('gameCompleteScreen');
const leaderboardScreen = document.getElementById('leaderboardScreen'); const deathScreen = document.getElementById('deathScreen'); const gameUI = document.getElementById('gameUI');
const startButton = document.getElementById('startButton'); const leaderboardButton = document.getElementById('leaderboardButton'); const backButton = document.getElementById('backButton');
const submitScoreButton = document.getElementById('submitScoreButton'); const replayButton = document.getElementById('replayButton'); const homeButton = document.getElementById('homeButton');
const nextLevelButton = document.getElementById('nextLevelButton'); const restartFromDeathButton = document.getElementById('restartFromDeathButton'); const homeFromDeathButton = document.getElementById('homeFromDeathButton');
const nameInput = document.getElementById('nameInput'); const bestTimeEl = document.getElementById('bestTime'); const finalTimeStat = document.getElementById('finalTimeStat');
const finalDeathsStat = document.getElementById('finalDeathsStat'); const leaderboardListEl = document.getElementById('leaderboardList'); const timerEl = document.getElementById('timer');
const deathsCounter = document.getElementById('deathsCounter'); const sprintStatusEl = document.getElementById('sprintStatus'); const levelStartBanner = document.getElementById('levelStartBanner');
const levelBannerText = document.getElementById('levelBannerText'); const deathOptions = document.getElementById('deathOptions'); const musicVolumeSlider = document.getElementById('musicVolumeSlider');
const sfxVolumeSlider = document.getElementById('sfxVolumeSlider'); const masterMuteCheckbox = document.getElementById('masterMuteCheckbox');
const powerupNotification = document.getElementById('powerupNotification'); const powerupMessage = document.getElementById('powerupMessage');

// --- Audio Setup ---
const backgroundMusic = new Audio('assets/background.mp3'); backgroundMusic.loop = true;
const gameOverMusic = new Audio('assets/gameover.mp3'); gameOverMusic.loop = false;

// --- Settings and Progress Management ---
let gameSettings = { musicVolume: 0.5, sfxVolume: 0.5, isMuted: false };
let unlockedPowers = { canPush: false, canDash: false };
function saveSettings() { localStorage.setItem('flowyJumperSettings', JSON.stringify(gameSettings)); }
function loadSettings() { const saved = localStorage.getItem('flowyJumperSettings'); if (saved) { gameSettings = JSON.parse(saved); } musicVolumeSlider.value = gameSettings.musicVolume; sfxVolumeSlider.value = gameSettings.sfxVolume; masterMuteCheckbox.checked = gameSettings.isMuted; applyAudioSettings(); }
function applyAudioSettings() { backgroundMusic.volume = gameSettings.musicVolume; gameOverMusic.volume = gameSettings.musicVolume; backgroundMusic.muted = gameSettings.isMuted; gameOverMusic.muted = gameSettings.isMuted; }
function saveProgress() { localStorage.setItem('flowyJumperProgress', JSON.stringify(unlockedPowers)); }
function loadProgress() { const saved = localStorage.getItem('flowyJumperProgress'); if (saved) { unlockedPowers = JSON.parse(saved); } }

// --- Constants ---
const WIDTH = 1024, HEIGHT = 768; canvas.width = WIDTH; canvas.height = HEIGHT;
const C_SKY_BLUE = '#87ceeb', C_PLAYER = '#ff7847', C_PLATFORM_GRASS = '#32cd32', C_PLATFORM_DIRT = '#8b4513', C_HAZARD = '#ff0000', C_GOAL = '#ffd700';
const PLAYER_ACC = 0.6, PLAYER_SPRINT_ACC = 1.2, PLAYER_FRICTION = -0.12, PLAYER_GRAVITY = 0.8, PLAYER_JUMP_STRENGTH = -18, PLAYER_SPRINT_JUMP_STRENGTH = -22, PLAYER_SPRINT_DURATION = 250, PLAYER_SPRINT_COOLDOWN = 1000;
const PLAYER_DASH_SPEED = 15, PLAYER_DASH_DURATION = 150;

// --- Game State and Classes ---
let keys = {}, player, platforms, pushableBlocks, hazards, goal, camera = { x: 0, y: 0 },
    levelStartTime, animationFrameId, currentLevelIndex = 0;
let gameState = 'START';
let totalPlaythroughTime = 0, totalDeaths = 0;

function isColliding(rect1, rect2) { return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y; }
class Player {
    constructor(x, y) { this.width = TILE_SIZE - 8; this.height = TILE_SIZE * 1.5; this.pos = { x, y }; this.vel = { x: 0, y: 0 }; this.jumpsLeft = 2; this.onGround = false; this.canDashInAir = true; this.isDashing = false; this.dashTimer = 0; this.isSprinting = false; this.sprintTimer = 0; this.sprintCooldownTimer = 0; }
    jump() { if (this.jumpsLeft > 0) { if (this.onGround && this.isSprinting) { this.vel.y = PLAYER_SPRINT_JUMP_STRENGTH; } else { this.vel.y = PLAYER_JUMP_STRENGTH; } this.jumpsLeft--; this.onGround = false; } }
    sprint() { if (this.onGround && performance.now() > this.sprintCooldownTimer) { this.isSprinting = true; this.sprintTimer = performance.now(); } }
    respawn(startPos) { this.pos.x = startPos.x; this.pos.y = startPos.y; this.vel = { x: 0, y: 0 }; this.onGround = false; this.isSprinting = false; this.isDashing = false; this.canDashInAir = true; }
    dash() { if (unlockedPowers.canDash && this.canDashInAir && !this.onGround) { this.isDashing = true; this.canDashInAir = false; this.dashTimer = performance.now(); const direction = (keys['a'] || keys['ArrowLeft']) ? -1 : (keys['d'] || keys['ArrowRight']) ? 1 : (this.vel.x !== 0 ? Math.sign(this.vel.x) : 1); this.vel.x = direction * PLAYER_DASH_SPEED; this.vel.y = 0; } }
    update(platforms, pushableBlocks) { if (this.isDashing) { this.vel.y = 0; if (performance.now() - this.dashTimer > PLAYER_DASH_DURATION) { this.isDashing = false; this.vel.y = -2; this.vel.x *= 0.5; } else { this.pos.x += this.vel.x; return; } } let accX = 0; const moveForce = (this.isSprinting && this.onGround) ? PLAYER_SPRINT_ACC : PLAYER_ACC; if (keys['a'] || keys['ArrowLeft']) accX = -moveForce; if (keys['d'] || keys['ArrowRight']) accX = moveForce; if (this.isSprinting && performance.now() - this.sprintTimer > PLAYER_SPRINT_DURATION) { this.isSprinting = false; this.sprintCooldownTimer = performance.now() + PLAYER_SPRINT_COOLDOWN; } if (accX === 0) { accX += this.vel.x * PLAYER_FRICTION; } this.vel.x += accX; this.vel.y += PLAYER_GRAVITY; if (this.vel.y > TILE_SIZE) this.vel.y = TILE_SIZE; const maxSpeed = (this.isSprinting && this.onGround) ? 12 : 7; if (Math.abs(this.vel.x) > maxSpeed) { this.vel.x = Math.sign(this.vel.x) * maxSpeed; } const allObstacles = [...platforms, ...pushableBlocks]; this.pos.y += this.vel.y; let playerRect = { x: this.pos.x, y: this.pos.y, width: this.width, height: this.height }; this.onGround = false; for (const p of allObstacles) { if (isColliding(playerRect, p)) { if (this.vel.y > 0) { this.pos.y = p.y - this.height; this.vel.y = 0; this.onGround = true; this.jumpsLeft = 2; this.canDashInAir = true; } else if (this.vel.y < 0) { this.pos.y = p.y + p.height; this.vel.y = 0; } } } this.pos.x += this.vel.x; playerRect = { x: this.pos.x, y: this.pos.y, width: this.width, height: this.height }; for (const block of pushableBlocks) { if (isColliding(playerRect, block)) { if (unlockedPowers.canPush) { block.push(this.vel.x, allObstacles, playerRect); } } } playerRect = { x: this.pos.x, y: this.pos.y, width: this.width, height: this.height }; for (const p of allObstacles) { if (isColliding(playerRect, p)) { if (this.vel.x > 0) { this.pos.x = p.x - this.width; } else if (this.vel.x < 0) { this.pos.x = p.x + p.width; } this.vel.x = 0; } } }
    draw(ctx) { ctx.fillStyle = C_PLAYER; ctx.fillRect(this.pos.x, this.pos.y, this.width, this.height); }
}
class Platform { constructor(x, y) { this.x = x; this.y = y; this.width = TILE_SIZE; this.height = TILE_SIZE; } draw(ctx) { const grassHeight = 8; ctx.fillStyle = C_PLATFORM_GRASS; ctx.fillRect(this.x, this.y, this.width, grassHeight); ctx.fillStyle = C_PLATFORM_DIRT; ctx.fillRect(this.x, this.y + grassHeight, this.width, this.height - grassHeight); } }
class Hazard { constructor(x,y) { this.x = x; this.y = y + TILE_SIZE / 2; this.width = TILE_SIZE; this.height = TILE_SIZE / 2; } draw(ctx) { ctx.fillStyle = C_HAZARD; ctx.fillRect(this.x, this.y, this.width, this.height); } }
class Goal { constructor(x,y) { this.x = x; this.y = y; this.width = TILE_SIZE; this.height = TILE_SIZE; } draw(ctx) { ctx.fillStyle = C_GOAL; ctx.fillRect(this.x, this.y, this.width, this.height); } }
class PushableBlock { constructor(x, y) { this.x = x; this.y = y; this.width = TILE_SIZE; this.height = TILE_SIZE; } push(amount, obstacles) { this.x += amount; for (const p of obstacles) { if (p === this) continue; if (isColliding(this, p)) { this.x = (amount > 0) ? p.x - this.width : p.x + p.width; return; } } } draw(ctx) { ctx.fillStyle = '#FFA500'; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeStyle = '#FF8C00'; ctx.lineWidth = 4; ctx.strokeRect(this.x + 4, this.y + 4, this.width - 8, this.height - 8); } }

// --- Game Logic ---
let gameStartPos = { x: 0, y: 0 };
function initLevel(levelIndex) { platforms = []; pushableBlocks = []; hazards = []; let foundStart = false; const levelMap = LEVEL_MAPS[levelIndex]; levelMap.forEach((row, rowIndex) => { for (let colIndex = 0; colIndex < row.length; colIndex++) { const tile = row[colIndex]; const x = colIndex * TILE_SIZE; const y = rowIndex * TILE_SIZE; if (tile === 'P') { platforms.push(new Platform(x, y)); if (levelMap[rowIndex-1] && levelMap[rowIndex-1][colIndex] === 'S' && !foundStart) { gameStartPos = { x: x + (TILE_SIZE / 2) - ((TILE_SIZE-8)/2), y: y - (TILE_SIZE * 1.5) }; foundStart = true; } } else if (tile === 'B') { pushableBlocks.push(new PushableBlock(x,y)); } else if (tile === 'H') { hazards.push(new Hazard(x, y)); } else if (tile === 'E') { goal = new Goal(x, y); } } }); player = new Player(gameStartPos.x, gameStartPos.y); }
function triggerDeathSequence() { if (gameState !== 'PLAYING') return; gameState = 'DEATH_SCREEN'; cancelAnimationFrame(animationFrameId); totalDeaths++; backgroundMusic.pause(); gameOverMusic.currentTime = 0; gameOverMusic.play().catch(e => console.error("Game over audio failed:", e)); gameUI.style.display = 'none'; deathScreen.style.display = 'flex'; deathOptions.style.visibility = 'hidden'; setTimeout(() => { if (gameState === 'DEATH_SCREEN') { deathOptions.style.visibility = 'visible'; } }, 3000); }
function checkOtherCollisions() { const playerRect = { x: player.pos.x, y: player.pos.y, width: player.width, height: player.height }; for(const h of hazards) { if (isColliding(playerRect, h)) { triggerDeathSequence(); return; } } if (goal && isColliding(playerRect, goal)) { completeLevel(); return; } if (player.pos.y > (LEVEL_MAPS[currentLevelIndex].length * TILE_SIZE) + 200) { triggerDeathSequence(); } }
function update() { if (gameState !== 'PLAYING') return; player.update(platforms, pushableBlocks); checkOtherCollisions(); const targetCamX = player.pos.x + player.width / 2 - WIDTH / 2; const targetCamY = player.pos.y + player.height / 2 - HEIGHT / 2; camera.x += (targetCamX - camera.x) * 0.08; camera.y += (targetCamY - camera.y) * 0.08; if (camera.x < 0) camera.x = 0; if (camera.x > (LEVEL_MAPS[currentLevelIndex][0].length * TILE_SIZE) - WIDTH) camera.x = (LEVEL_MAPS[currentLevelIndex][0].length * TILE_SIZE) - WIDTH; if (camera.y < 0) camera.y = 0; if (camera.y > (LEVEL_MAPS[currentLevelIndex].length * TILE_SIZE) - HEIGHT) camera.y = (LEVEL_MAPS[currentLevelIndex].length * TILE_SIZE) - HEIGHT; const elapsedTime = (performance.now() - levelStartTime) / 1000; timerEl.textContent = `Time: ${elapsedTime.toFixed(2)}`; deathsCounter.textContent = `Deaths: ${totalDeaths}`; if (player.isSprinting) { sprintStatusEl.textContent = 'SPRINT!'; sprintStatusEl.style.color = C_PLAYER; } else if (performance.now() < player.sprintCooldownTimer) { sprintStatusEl.textContent = 'Cooldown'; sprintStatusEl.style.color = 'black'; } else { sprintStatusEl.textContent = 'Sprint Ready'; sprintStatusEl.style.color = 'green'; } }
function draw() { ctx.clearRect(0, 0, WIDTH, HEIGHT); ctx.save(); ctx.translate(-camera.x, -camera.y); platforms.forEach(p => p.draw(ctx)); pushableBlocks.forEach(b => b.draw(ctx)); hazards.forEach(h => h.draw(ctx)); if (goal) goal.draw(ctx); if (player) player.draw(ctx); ctx.restore(); }
function gameLoop() { if (gameState === 'START') return; update(); draw(); animationFrameId = requestAnimationFrame(gameLoop); }

// --- Game State Management ---
function startGame(levelIndex) { if (levelIndex === 0) { totalPlaythroughTime = 0; totalDeaths = 0; unlockedPowers = { canPush: false, canDash: false }; saveProgress(); } currentLevelIndex = levelIndex; startScreen.style.display = 'none'; intermissionScreen.style.display = 'none'; gameCompleteScreen.style.display = 'none'; deathScreen.style.display = 'none'; gameUI.style.display = 'none'; gameOverMusic.pause(); gameOverMusic.currentTime = 0; if (backgroundMusic.paused) { backgroundMusic.play().catch(e => console.error("Audio play failed:", e)); } initLevel(levelIndex); camera.x = player.pos.x - WIDTH / 2; gameState = 'LEVEL_START'; levelBannerText.textContent = `Level ${levelIndex + 1}`; levelStartBanner.style.display = 'flex'; if(animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = requestAnimationFrame(gameLoop); setTimeout(() => { if (gameState !== 'LEVEL_START') return; levelStartBanner.style.display = 'none'; gameUI.style.display = 'flex'; levelStartTime = performance.now(); gameState = 'PLAYING'; }, 1500); }
function completeLevel() { if (gameState !== 'PLAYING') return; cancelAnimationFrame(animationFrameId); const levelTime = (performance.now() - levelStartTime) / 1000; totalPlaythroughTime += levelTime; let newPowerUnlocked = false; let powerupMsg = ""; if(currentLevelIndex === 2 && !unlockedPowers.canPush) { unlockedPowers.canPush = true; newPowerUnlocked = true; powerupMsg = "You can now PUSH orange blocks by walking into them!"; } if(currentLevelIndex === 6 && !unlockedPowers.canDash) { unlockedPowers.canDash = true; newPowerUnlocked = true; powerupMsg = "Press [X] in mid-air to DASH forward!"; } if(newPowerUnlocked) { saveProgress(); powerupNotification.style.display = 'block'; powerupMessage.textContent = powerupMsg; } else { powerupNotification.style.display = 'none'; } const isLastLevel = currentLevelIndex >= LEVEL_MAPS.length - 1; if (isLastLevel) { showGameCompleteScreen(); } else { showIntermissionScreen(); } }
function showIntermissionScreen() { gameState = 'INTERMISSION'; gameUI.style.display = 'none'; intermissionScreen.style.display = 'flex'; }
function showGameCompleteScreen() { gameState = 'GAME_COMPLETE'; backgroundMusic.pause(); backgroundMusic.currentTime = 0; gameOverMusic.play().catch(e => console.error("Audio play failed:", e)); gameUI.style.display = 'none'; gameCompleteScreen.style.display = 'flex'; finalTimeStat.textContent = `${totalPlaythroughTime.toFixed(2)}s`; finalDeathsStat.textContent = totalDeaths; nameInput.focus(); }
function showStartScreen() { gameState = 'START'; startScreen.style.display = 'flex'; intermissionScreen.style.display = 'none'; gameCompleteScreen.style.display = 'none'; leaderboardScreen.style.display = 'none'; deathScreen.style.display = 'none'; gameUI.style.display = 'none'; gameOverMusic.pause(); gameOverMusic.currentTime = 0; const leaderboard = loadLeaderboard(); bestTimeEl.textContent = (leaderboard.length > 0) ? `Best Run: ${leaderboard[0].time.toFixed(2)}s, ${leaderboard[0].deaths} deaths` : 'Be the first to set a time!'; }
function showLeaderboard() { startScreen.style.display = 'none'; leaderboardScreen.style.display = 'flex'; const leaderboard = loadLeaderboard(); leaderboardListEl.innerHTML = ''; if (leaderboard.length === 0) { leaderboardListEl.innerHTML = '<div>No scores yet!</div>'; } else { leaderboard.forEach((entry, index) => { let div = document.createElement('div'); div.textContent = `${index + 1}. ${entry.name} - Time: ${entry.time.toFixed(2)}s, Deaths: ${entry.deaths}`; leaderboardListEl.appendChild(div); }); } }
function loadLeaderboard() { const data = localStorage.getItem('flowyJumperLeaderboard'); return data ? JSON.parse(data) : []; }
function saveLeaderboard(name, time, deaths) { if (!name) name = 'Anonymous'; const leaderboard = loadLeaderboard(); leaderboard.push({ name, time, deaths }); leaderboard.sort((a, b) => { if (a.time < b.time) return -1; if (a.time > b.time) return 1; return a.deaths - b.deaths; }); localStorage.setItem('flowyJumperLeaderboard', JSON.stringify(leaderboard.slice(0, 10))); }

// --- Event Listeners ---
window.addEventListener('keydown', (e) => { const key = e.key.toLowerCase(); keys[key] = true; if (gameState === 'PLAYING') { if (key === ' ' || key === 'w' || key === 'arrowup') { e.preventDefault(); player.jump(); } if (key === 'shift') { player.sprint(); } if (key === 'x') { player.dash(); } if (key === 'r') { triggerDeathSequence(); } } if (gameState === 'GAME_COMPLETE' && key === 'enter') { submitScoreButton.click(); } });
window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
startButton.addEventListener('click', () => { startGame(0); });
musicVolumeSlider.addEventListener('input', (e) => { gameSettings.musicVolume = e.target.value; applyAudioSettings(); saveSettings(); });
sfxVolumeSlider.addEventListener('input', (e) => { gameSettings.sfxVolume = e.target.value; saveSettings(); });
masterMuteCheckbox.addEventListener('change', (e) => { gameSettings.isMuted = e.target.checked; applyAudioSettings(); saveSettings(); });
leaderboardButton.addEventListener('click', showLeaderboard);
backButton.addEventListener('click', showStartScreen);
submitScoreButton.addEventListener('click', () => { saveLeaderboard(nameInput.value, totalPlaythroughTime, totalDeaths); nameInput.value = ''; showStartScreen(); });
replayButton.addEventListener('click', () => startGame(currentLevelIndex));
homeButton.addEventListener('click', showStartScreen);
nextLevelButton.addEventListener('click', () => startGame(currentLevelIndex + 1));
restartFromDeathButton.addEventListener('click', () => startGame(currentLevelIndex));
homeFromDeathButton.addEventListener('click', showStartScreen);

// --- Initial Call ---
loadSettings();
loadProgress();
showStartScreen();